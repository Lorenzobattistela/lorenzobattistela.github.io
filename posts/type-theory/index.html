<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1.0" data-next-head=""/><meta name="author" content="Lorenzo Battistela" data-next-head=""/><link rel="icon" href="/favicon.ico" data-next-head=""/><title data-next-head=""></title><meta name="description" content="Basics of TT" data-next-head=""/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/966ef0bc2ff51cf6.css" as="style"/><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&amp;family=IBM+Plex+Sans:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="/_next/static/css/966ef0bc2ff51cf6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-afbe389e5387c555.js" defer=""></script><script src="/_next/static/chunks/framework-d7f578ab3069408c.js" defer=""></script><script src="/_next/static/chunks/main-a5703b490a653431.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d35945f6f2ae940c.js" defer=""></script><script src="/_next/static/chunks/230-8a10a6030a242aaa.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-9da8c7586f67ce5f.js" defer=""></script><script src="/_next/static/ydYcoKj9y-mj7XR-0MT3a/_buildManifest.js" defer=""></script><script src="/_next/static/ydYcoKj9y-mj7XR-0MT3a/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="container"><canvas class="background-canvas"></canvas><main class="post-content"><nav class="post-nav"><div class="post-nav-left"><a href="/">← Home</a></div><div class="post-nav-right"><div class="animation-controls"><button class="animation-toggle" aria-label="Disable background animation">Disable Animation</button><button class="animation-speed" aria-label="Current speed: Medium">Speed: <!-- -->Medium</button></div></div></nav><article><h1>Type Theory 101</h1><div class="post-meta"><time>2024-05-21</time></div><div class="markdown-content"><p>A few months ago, I had contact with some really interesting open source projects. Compilers, languages, runtimes, mostly low level stuff I had little to no contact before. So I decided to dive in, and started studying. I ended up discovering a whole new world of theories, proofs and research.</p>
<p>But I felt I did not know the basics, the fundamentals of it — mainly because when trying to read an article, I even had trouble understanding the notation.</p>
<p>Have you ever seen something like this?</p>
<p><img src="/images/type-theory/1.webp" alt="typing rule"></p>
<p>It really seems complicated, but it is no monster. Let’s learn how to read this and what is type theory.</p>
<hr>
<h2>A little bit of history</h2>
<p>We all know what a paradox is. Sometimes we hear some fun ones that make us think, such as the <a href="https://en.wikipedia.org/wiki/Twin_paradox">Twin Paradox.</a> What happens is that physics and math are sources of many paradoxes. One of them is Russell’s paradox, which is a set-theoretic paradox that shows that every set theory that contains an unrestricted comprehension principle leads to contradictions. Basically, for any property, there is a set of all and only the objects that have that property. Then we have a set R that is the set of all sets that are not member of themselves. If R is not a member of itself, then its definition entails that it is a member of itself. Otherwise, if it is a member of itself, then it is not a member of itself since this is the set of all the sets that are not members of themselves.</p>
<p>Well that is confusing, but read it slowly and understand the problem here.</p>
<p>Type theory was created with the goal of avoiding paradoxes in a math equation based on set theory and formal logic. After that, we had progress on type theory such as ramified type theory together with an axiom of reducibility.</p>
<p>We also have Alonzo Church into play with his Lambda Calculus — which is the most popular conjunction of type theory. Church demonstrated it as a foundation of mathematics — a higher-order logic.</p>
<p>In modern literature, type theory usually refers to a typed system based on lambda calculus. Influential systems worth mentioning is Martin-Lofs intuitionistic type theory and Thierry Coquands calculus of constructions.</p>
<hr>
<h2>Introducing Type Theory</h2>
<p>As the name states, in type theory, the basic object of study is a type. I am sure you are familiar with some types. For example, natural number is a type, usually denoted <code>nat</code> . Integer is also a type. <code>=</code> is a type called the identity type.</p>
<p>Types can have terms (or terms can have types?). For example, 1 is a term of type <code>nat</code> , and we can declare it as <code>1 : nat</code> . This is a type declaration. This may sound familiar if you have experience with statically typed programming languages like Rust.</p>
<p>We also have a special type called <code>Type</code> . As you may imagine, it is used to define the type of a type. So, for example, <code>nat : Type</code> is a valid declaration.</p>
<p>Type theory is a subject that grows along with more fields, (such as category theory and proof theory) and we can have multiple interpretations for types. Here are some of them:</p>
<ul>
<li>A type is a set, and a term is an element of this set</li>
<li>A type is a space, and a term is a point in this space</li>
<li>A type is a proposition, and a term is a proof of this proposition</li>
</ul>
<p>Let’s introduce judgements, and a new symbol: <code>⊢</code></p>
<p>How do we read the following judgement?</p>
<p><code>⊢ A : Type</code></p>
<p>We can read this as: A is of type Type. This is a simple judgement.</p>
<p>Another symbol is used to represent Context: Γ (Gamma).</p>
<p>Γ is a finite sequence of type declarations, aka context. Intuitively, this mean that the assumptions in the left-hand context imply the right-hand side.</p>
<p><code>Γ ⊢ A : Type</code></p>
<p>We read this as: Under context gamma, A is of type Type</p>
<p>What about the following?</p>
<p><code>Γ ⊢ A === B : Type</code></p>
<p>This triple equal sign stands for judgemental equality. In type theory, we can have multiple types of equality, and note that this is different from the = sign stated as identity. So, Under context Gamma, A is judgementally equal to B which has type Type.</p>
<hr>
<h2>Function types</h2>
<p>Most modern type theories introduce function types. They are introduced with an arrow symbol, and are defined inductively. For example, if <code>a</code> and <code>b</code> are types, then <code>a-&gt;b</code> is the type of a function which takes a parameter of type <code>a</code> and returns a term of type <code>b</code> . Types of this form are also known as simple types.</p>
<p>Let’s walk through a simple example:</p>
<pre><code>// add: a function that takes two natural numbers and return one nat number  
add : nat -&gt; (nat -&gt; nat)
</code></pre>
<p>You may find weird the parentheses, since we’re all used with something like <code>add(a : nat, b : nat) -&gt; : nat</code> . What happens is that, strictly speaking, a simple type only allows for one input and one output, and this way, we could not receive two args in the way I wrote. Therefore, a better way to read this is: <code>add</code> is a function which takes a <code>nat</code> and returns another function of the form <code>nat -&gt; nat</code> . Note that the arrow is right associative.</p>
<p>Ok, but untill now Type theories seem pretty inofensive right? What can we do about it? What this has to do with the image in the beginning of the article?</p>
<p>Well, the power of type theories is in specifying how terms may be combined through inference rules. For example, for functions we have function application. If <code>a</code> is a term of type <code>c -&gt; d</code> and <code>b</code> is a term of type <code>c</code> , then the application of <code>a</code> to <code>b</code> , often written <code>( a b)</code> has type <code>d</code> . Example:</p>
<pre><code>3 : nat  
6 : nat  
10 : nat  
  
(add 3) : nat -&gt; nat // partial application 3 + x  
((add 6) 3) : nat // 9  
((add 10) ((add 3) 6)) : nat // results in (10 + (3 + 6)) = 19
</code></pre>
<p>Note that function application is left associative.</p>
<hr>
<h2>Computation</h2>
<p>Type theory has a built-in notation of computation. The following terms are different:</p>
<pre><code>1 + 5 : nat  
3 + 3 : nat  
0 + 6 : nat
</code></pre>
<p>But as you can see, they all compute to <code>6 : nat</code> . The concept of reduction / reduce to refer to computation. Example: <code>3 + 3 : nat</code> reduces to <code>6 : nat</code> and we can write this as: <code>3 + 3 : nat -&gt;&gt; 6 : nat</code> . A term without any variables that cannot be reduced further is called a canonical term.</p>
<p>Terms that compute to the same term are equal. As I said before, equality is quite complex on type theory, and the equality we’re referring here is when two terms can be substituted for each other. For example:</p>
<pre><code>x : nat  
x + (10 + 2) : nat  
x + (5 + 7) : nat  
  
x + (10 + 2) : nat -&gt;&gt; x + 12 : nat  
x + (5 + 7) : nat -&gt;&gt; x + 12 : nat
</code></pre>
<p>The terms above are judgementally equal.</p>
<p>OK, now that we discussed a little bit the basics, let’s try to develop a little bit more the function type (coming from lambda calculus). Let’s introduce it with a formal notation and then move forward to other types.</p>
<hr>
<h2>Function Types to Lambda Calculus : A formal formation</h2>
<p>As discussed before, given two types A and B, there is a type <code>A -&gt; B</code>.</p>
<p>We can write the formation rule for function types as follows:</p>
<p><img src="/images/type-theory/2.webp" alt="formation rule"></p>
<p>Remember that Γ stands for context. A formation rule, as its name states, gives us a way to form function types.</p>
<p>We can read this rule as: Under context Gamma, if A is of type Type and B is of type Type, then we have a function from type A to type B.</p>
<p>But besides that, we cannot do anything more yet. Here it comes the introduction rule:</p>
<p><img src="/images/type-theory/3.webp" alt="introduction rule"></p>
<p>We can read this as: Under context gamma, assume x is of type A. If b is of type B, then we have a function of type A that goes to type B receiving b as an argument.</p>
<p>The introduction rule states that, to specify a term of <code>A -&gt; B</code>, it is sufficient to specify a term <code>b : B</code> for every <code>x : A</code> . To understand this rule, it is important to understand the lambda calculus representation of functions. So, for example: we can say that <code>λx.λy.( x y )</code> is a lambda term that receives two arguments, x and y, and applies x to y. When we receive an x and y, we substitute them in the term: <code>λx.λy ( x y ) negate 1 =&gt; ( negate 1 )</code>.</p>
<p>That said, now we have terms of <code>A -&gt; B</code> but we have no rules to use them in a way. Now we need to introduce an <strong>elimination</strong> rule. The elimination rule for function type says that, given a function <code>f : A -&gt; B</code> and a term <code>a : A</code> we can form the term <code>f(a) : B</code> . Formally:</p>
<p><img src="/images/type-theory/4.webp" alt="elimination rule"></p>
<p>But well, we have no way to compute that. We do not know how to compute that. So, we have a computation rule that tells us what happens when the elimination rule is applied to a result of the introduction rule (in this case, a new function type).</p>
<p><img src="/images/type-theory/5.webp" alt="function type"></p>
<p>The notation <code>b[a / x] : B</code> is the term that we obtain from <code>b</code> by substituting <code>a</code> for every <code>x</code> . Therefore, we can read it as:</p>
<p>Under context gamma, assume x is of type A. if b is of type B and a of type A, we have a function that receives b as an argument and it is judgementally equal to the term where we substitute all occurrences of x in b for a.</p>
<p>To sum up, our rules state the following:</p>
<ul>
<li>For any type A and B, there is a type A -&gt; B called the function type. A term of A -&gt; B is called a function</li>
<li>Defining a function <code>f : A -&gt; B</code> is equivalent to defining a term <code>f(x) : B</code> for every <code>x : A</code> .</li>
</ul>
<p>And, as I said before, type theory has many interpretations. About functions we can say that:</p>
<ul>
<li>For sets, it is the set of functions from set A to set B.</li>
<li>For spaces, it is a space of function from A to B</li>
<li>For propositions, this represents A implies B since having a proof o A -&gt; B is equivalent to having a proof of B for every proof of A.</li>
</ul>
<p>In the next article of this type theory series, we will discuss more this rules and introduce new types. If you find any mistake or typo, feel free to comment, as I’m still pretty new to this subject as well. Thanks for reading!</p>
<hr>
<h2>References</h2>
<p><a href="https://en.wikipedia.org/wiki/Type_theory?source=post_page-----437df9e418c5--------------------------------">Type theory - Wikipedia</a></p>
<p><a href="https://plato.stanford.edu/entries/type-theory/?source=post_page-----437df9e418c5--------------------------------">Type Theory</a></p>
<p><a href="https://ncatlab.org/nlab/show/type+theory?source=post_page-----437df9e418c5--------------------------------">nLab type theory</a></p>
<p><a href="https://en.wikipedia.org/wiki/History_of_type_theory?source=post_page-----437df9e418c5--------------------------------">History of type theory - Wikipedia</a></p>
<p>And papers in the reference of those :)</p>
</div></article></main><footer><div class="footer-content"><p><a href="https://github.com/Lorenzobattistela" target="_blank" rel="noopener noreferrer">GitHub</a></p></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"type-theory","contentHtml":"\u003cp\u003eA few months ago, I had contact with some really interesting open source projects. Compilers, languages, runtimes, mostly low level stuff I had little to no contact before. So I decided to dive in, and started studying. I ended up discovering a whole new world of theories, proofs and research.\u003c/p\u003e\n\u003cp\u003eBut I felt I did not know the basics, the fundamentals of it — mainly because when trying to read an article, I even had trouble understanding the notation.\u003c/p\u003e\n\u003cp\u003eHave you ever seen something like this?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/type-theory/1.webp\" alt=\"typing rule\"\u003e\u003c/p\u003e\n\u003cp\u003eIt really seems complicated, but it is no monster. Let’s learn how to read this and what is type theory.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eA little bit of history\u003c/h2\u003e\n\u003cp\u003eWe all know what a paradox is. Sometimes we hear some fun ones that make us think, such as the \u003ca href=\"https://en.wikipedia.org/wiki/Twin_paradox\"\u003eTwin Paradox.\u003c/a\u003e What happens is that physics and math are sources of many paradoxes. One of them is Russell’s paradox, which is a set-theoretic paradox that shows that every set theory that contains an unrestricted comprehension principle leads to contradictions. Basically, for any property, there is a set of all and only the objects that have that property. Then we have a set R that is the set of all sets that are not member of themselves. If R is not a member of itself, then its definition entails that it is a member of itself. Otherwise, if it is a member of itself, then it is not a member of itself since this is the set of all the sets that are not members of themselves.\u003c/p\u003e\n\u003cp\u003eWell that is confusing, but read it slowly and understand the problem here.\u003c/p\u003e\n\u003cp\u003eType theory was created with the goal of avoiding paradoxes in a math equation based on set theory and formal logic. After that, we had progress on type theory such as ramified type theory together with an axiom of reducibility.\u003c/p\u003e\n\u003cp\u003eWe also have Alonzo Church into play with his Lambda Calculus — which is the most popular conjunction of type theory. Church demonstrated it as a foundation of mathematics — a higher-order logic.\u003c/p\u003e\n\u003cp\u003eIn modern literature, type theory usually refers to a typed system based on lambda calculus. Influential systems worth mentioning is Martin-Lofs intuitionistic type theory and Thierry Coquands calculus of constructions.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eIntroducing Type Theory\u003c/h2\u003e\n\u003cp\u003eAs the name states, in type theory, the basic object of study is a type. I am sure you are familiar with some types. For example, natural number is a type, usually denoted \u003ccode\u003enat\u003c/code\u003e . Integer is also a type. \u003ccode\u003e=\u003c/code\u003e is a type called the identity type.\u003c/p\u003e\n\u003cp\u003eTypes can have terms (or terms can have types?). For example, 1 is a term of type \u003ccode\u003enat\u003c/code\u003e , and we can declare it as \u003ccode\u003e1 : nat\u003c/code\u003e . This is a type declaration. This may sound familiar if you have experience with statically typed programming languages like Rust.\u003c/p\u003e\n\u003cp\u003eWe also have a special type called \u003ccode\u003eType\u003c/code\u003e . As you may imagine, it is used to define the type of a type. So, for example, \u003ccode\u003enat : Type\u003c/code\u003e is a valid declaration.\u003c/p\u003e\n\u003cp\u003eType theory is a subject that grows along with more fields, (such as category theory and proof theory) and we can have multiple interpretations for types. Here are some of them:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA type is a set, and a term is an element of this set\u003c/li\u003e\n\u003cli\u003eA type is a space, and a term is a point in this space\u003c/li\u003e\n\u003cli\u003eA type is a proposition, and a term is a proof of this proposition\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s introduce judgements, and a new symbol: \u003ccode\u003e⊢\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eHow do we read the following judgement?\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e⊢ A : Type\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe can read this as: A is of type Type. This is a simple judgement.\u003c/p\u003e\n\u003cp\u003eAnother symbol is used to represent Context: Γ (Gamma).\u003c/p\u003e\n\u003cp\u003eΓ is a finite sequence of type declarations, aka context. Intuitively, this mean that the assumptions in the left-hand context imply the right-hand side.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eΓ ⊢ A : Type\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eWe read this as: Under context gamma, A is of type Type\u003c/p\u003e\n\u003cp\u003eWhat about the following?\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eΓ ⊢ A === B : Type\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis triple equal sign stands for judgemental equality. In type theory, we can have multiple types of equality, and note that this is different from the = sign stated as identity. So, Under context Gamma, A is judgementally equal to B which has type Type.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eFunction types\u003c/h2\u003e\n\u003cp\u003eMost modern type theories introduce function types. They are introduced with an arrow symbol, and are defined inductively. For example, if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are types, then \u003ccode\u003ea-\u0026gt;b\u003c/code\u003e is the type of a function which takes a parameter of type \u003ccode\u003ea\u003c/code\u003e and returns a term of type \u003ccode\u003eb\u003c/code\u003e . Types of this form are also known as simple types.\u003c/p\u003e\n\u003cp\u003eLet’s walk through a simple example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// add: a function that takes two natural numbers and return one nat number  \nadd : nat -\u0026gt; (nat -\u0026gt; nat)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou may find weird the parentheses, since we’re all used with something like \u003ccode\u003eadd(a : nat, b : nat) -\u0026gt; : nat\u003c/code\u003e . What happens is that, strictly speaking, a simple type only allows for one input and one output, and this way, we could not receive two args in the way I wrote. Therefore, a better way to read this is: \u003ccode\u003eadd\u003c/code\u003e is a function which takes a \u003ccode\u003enat\u003c/code\u003e and returns another function of the form \u003ccode\u003enat -\u0026gt; nat\u003c/code\u003e . Note that the arrow is right associative.\u003c/p\u003e\n\u003cp\u003eOk, but untill now Type theories seem pretty inofensive right? What can we do about it? What this has to do with the image in the beginning of the article?\u003c/p\u003e\n\u003cp\u003eWell, the power of type theories is in specifying how terms may be combined through inference rules. For example, for functions we have function application. If \u003ccode\u003ea\u003c/code\u003e is a term of type \u003ccode\u003ec -\u0026gt; d\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e is a term of type \u003ccode\u003ec\u003c/code\u003e , then the application of \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003eb\u003c/code\u003e , often written \u003ccode\u003e( a b)\u003c/code\u003e has type \u003ccode\u003ed\u003c/code\u003e . Example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e3 : nat  \n6 : nat  \n10 : nat  \n  \n(add 3) : nat -\u0026gt; nat // partial application 3 + x  \n((add 6) 3) : nat // 9  \n((add 10) ((add 3) 6)) : nat // results in (10 + (3 + 6)) = 19\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that function application is left associative.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eComputation\u003c/h2\u003e\n\u003cp\u003eType theory has a built-in notation of computation. The following terms are different:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1 + 5 : nat  \n3 + 3 : nat  \n0 + 6 : nat\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut as you can see, they all compute to \u003ccode\u003e6 : nat\u003c/code\u003e . The concept of reduction / reduce to refer to computation. Example: \u003ccode\u003e3 + 3 : nat\u003c/code\u003e reduces to \u003ccode\u003e6 : nat\u003c/code\u003e and we can write this as: \u003ccode\u003e3 + 3 : nat -\u0026gt;\u0026gt; 6 : nat\u003c/code\u003e . A term without any variables that cannot be reduced further is called a canonical term.\u003c/p\u003e\n\u003cp\u003eTerms that compute to the same term are equal. As I said before, equality is quite complex on type theory, and the equality we’re referring here is when two terms can be substituted for each other. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ex : nat  \nx + (10 + 2) : nat  \nx + (5 + 7) : nat  \n  \nx + (10 + 2) : nat -\u0026gt;\u0026gt; x + 12 : nat  \nx + (5 + 7) : nat -\u0026gt;\u0026gt; x + 12 : nat\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe terms above are judgementally equal.\u003c/p\u003e\n\u003cp\u003eOK, now that we discussed a little bit the basics, let’s try to develop a little bit more the function type (coming from lambda calculus). Let’s introduce it with a formal notation and then move forward to other types.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eFunction Types to Lambda Calculus : A formal formation\u003c/h2\u003e\n\u003cp\u003eAs discussed before, given two types A and B, there is a type \u003ccode\u003eA -\u0026gt; B\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe can write the formation rule for function types as follows:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/type-theory/2.webp\" alt=\"formation rule\"\u003e\u003c/p\u003e\n\u003cp\u003eRemember that Γ stands for context. A formation rule, as its name states, gives us a way to form function types.\u003c/p\u003e\n\u003cp\u003eWe can read this rule as: Under context Gamma, if A is of type Type and B is of type Type, then we have a function from type A to type B.\u003c/p\u003e\n\u003cp\u003eBut besides that, we cannot do anything more yet. Here it comes the introduction rule:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/type-theory/3.webp\" alt=\"introduction rule\"\u003e\u003c/p\u003e\n\u003cp\u003eWe can read this as: Under context gamma, assume x is of type A. If b is of type B, then we have a function of type A that goes to type B receiving b as an argument.\u003c/p\u003e\n\u003cp\u003eThe introduction rule states that, to specify a term of \u003ccode\u003eA -\u0026gt; B\u003c/code\u003e, it is sufficient to specify a term \u003ccode\u003eb : B\u003c/code\u003e for every \u003ccode\u003ex : A\u003c/code\u003e . To understand this rule, it is important to understand the lambda calculus representation of functions. So, for example: we can say that \u003ccode\u003eλx.λy.( x y )\u003c/code\u003e is a lambda term that receives two arguments, x and y, and applies x to y. When we receive an x and y, we substitute them in the term: \u003ccode\u003eλx.λy ( x y ) negate 1 =\u0026gt; ( negate 1 )\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThat said, now we have terms of \u003ccode\u003eA -\u0026gt; B\u003c/code\u003e but we have no rules to use them in a way. Now we need to introduce an \u003cstrong\u003eelimination\u003c/strong\u003e rule. The elimination rule for function type says that, given a function \u003ccode\u003ef : A -\u0026gt; B\u003c/code\u003e and a term \u003ccode\u003ea : A\u003c/code\u003e we can form the term \u003ccode\u003ef(a) : B\u003c/code\u003e . Formally:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/type-theory/4.webp\" alt=\"elimination rule\"\u003e\u003c/p\u003e\n\u003cp\u003eBut well, we have no way to compute that. We do not know how to compute that. So, we have a computation rule that tells us what happens when the elimination rule is applied to a result of the introduction rule (in this case, a new function type).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/type-theory/5.webp\" alt=\"function type\"\u003e\u003c/p\u003e\n\u003cp\u003eThe notation \u003ccode\u003eb[a / x] : B\u003c/code\u003e is the term that we obtain from \u003ccode\u003eb\u003c/code\u003e by substituting \u003ccode\u003ea\u003c/code\u003e for every \u003ccode\u003ex\u003c/code\u003e . Therefore, we can read it as:\u003c/p\u003e\n\u003cp\u003eUnder context gamma, assume x is of type A. if b is of type B and a of type A, we have a function that receives b as an argument and it is judgementally equal to the term where we substitute all occurrences of x in b for a.\u003c/p\u003e\n\u003cp\u003eTo sum up, our rules state the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor any type A and B, there is a type A -\u0026gt; B called the function type. A term of A -\u0026gt; B is called a function\u003c/li\u003e\n\u003cli\u003eDefining a function \u003ccode\u003ef : A -\u0026gt; B\u003c/code\u003e is equivalent to defining a term \u003ccode\u003ef(x) : B\u003c/code\u003e for every \u003ccode\u003ex : A\u003c/code\u003e .\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd, as I said before, type theory has many interpretations. About functions we can say that:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFor sets, it is the set of functions from set A to set B.\u003c/li\u003e\n\u003cli\u003eFor spaces, it is a space of function from A to B\u003c/li\u003e\n\u003cli\u003eFor propositions, this represents A implies B since having a proof o A -\u0026gt; B is equivalent to having a proof of B for every proof of A.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the next article of this type theory series, we will discuss more this rules and introduce new types. If you find any mistake or typo, feel free to comment, as I’m still pretty new to this subject as well. Thanks for reading!\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eReferences\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Type_theory?source=post_page-----437df9e418c5--------------------------------\"\u003eType theory - Wikipedia\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://plato.stanford.edu/entries/type-theory/?source=post_page-----437df9e418c5--------------------------------\"\u003eType Theory\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ncatlab.org/nlab/show/type+theory?source=post_page-----437df9e418c5--------------------------------\"\u003enLab type theory\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/History_of_type_theory?source=post_page-----437df9e418c5--------------------------------\"\u003eHistory of type theory - Wikipedia\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAnd papers in the reference of those :)\u003c/p\u003e\n","title":"Type Theory 101","description":"Basics of TT","date":"2024-05-21"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"type-theory"},"buildId":"ydYcoKj9y-mj7XR-0MT3a","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>