<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width, initial-scale=1.0" data-next-head=""/><meta name="author" content="Lorenzo Battistela" data-next-head=""/><link rel="icon" href="/favicon.ico" data-next-head=""/><title data-next-head=""></title><meta name="description" content="Understanding EAL and typechecking it" data-next-head=""/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/966ef0bc2ff51cf6.css" as="style"/><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&amp;family=IBM+Plex+Sans:wght@400;500;600;700&amp;display=swap" rel="stylesheet"/><link rel="stylesheet" href="/_next/static/css/966ef0bc2ff51cf6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/_next/static/chunks/webpack-afbe389e5387c555.js" defer=""></script><script src="/_next/static/chunks/framework-d7f578ab3069408c.js" defer=""></script><script src="/_next/static/chunks/main-a5703b490a653431.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d35945f6f2ae940c.js" defer=""></script><script src="/_next/static/chunks/230-8a10a6030a242aaa.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-9da8c7586f67ce5f.js" defer=""></script><script src="/_next/static/7XdtTWnKkLqV613zeyCgO/_buildManifest.js" defer=""></script><script src="/_next/static/7XdtTWnKkLqV613zeyCgO/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="container"><canvas class="background-canvas"></canvas><main class="post-content"><nav class="post-nav"><div class="post-nav-left"><a href="/">← Home</a></div><div class="post-nav-right"><div class="animation-controls"><button class="animation-toggle" aria-label="Disable background animation">Disable Animation</button><button class="animation-speed" aria-label="Current speed: Medium">Speed: <!-- -->Medium</button></div></div></nav><article><h1>Elementary Affine Logic</h1><div class="post-meta"><time>2025-02-22</time></div><div class="markdown-content"><p>Elementary Affine Logic (EAL) is a type system designed to guarantee that programs terminate in elementary time—a complexity class bounded by finite towers of exponentials, such as 
<code>2^(2^n)</code>
. This makes EAL a powerful framework for reasoning about computational efficiency in a rigorous way. For this article, we&#39;ll focus on propositional EAL without quantification, keeping our exploration accessible while diving into its core concepts and implementation. It is important to note that the implementation is not focusing on performance and not performing type inference, only basic type checking.</p>
<p>EAL is built upon affine logic, a substructural logic that modifies traditional proof theory by rejecting the contraction rule, which prevents assumptions from being reused multiple times, while embracing weakening, allowing unused variables to remain in the context. This contrasts with linear logic, where variables must be used exactly once; affine logic relaxes this to &quot;at most once,&quot; providing flexibility to ignore resources if they are not needed. In the context of programming, particularly within lambda calculus, this translates to a system where function arguments are used at most once, with some potentially left unused. EAL extends this foundation to target terms that align with the computational power of elementary bounded Turing machines. It also connects to Lamping&#39;s optimal reduction algorithm, which minimizes the number of beta-reduction steps, ensuring efficient normalization of terms.</p>
<h3>Core Characteristics of EAL</h3>
<p>EAL is specifically crafted to type terms that can be reduced in elementary time, leveraging affine logic&#39;s resource-sensitive nature. Variables cannot be reused unless explicitly marked with the bang modality (!A), which allows controlled reuse, while unused assumptions are permitted, aligning with the weakening rule. The bang modality (!A) is central to EAL, selectively relaxing the &quot;at most once&quot; rule to balance efficiency and flexibility. However, this imposes restrictions, preventing constructs like extensive variable sharing or polymorphism from being typed within the system—a necessary trade-off for EAL&#39;s performance guarantees.</p>
<h3>Implementing EAL</h3>
<p>Now let&#39;s gets get to work and write a simple implementation of EAL in Haskell.
This implementation focuses on the concept and the simple typing rules, not in
performance neither the type inference (that is more complex).</p>
<p>The first step is to define the types and terms that constitute the EAL system:</p>
<pre><code class="language-haskell">-- Type definitions
data Type
  = TVar String          -- Type variable, e.g., &quot;a&quot;
  | Bang Type            -- !A, for reusable terms
  | Type :-&gt; Type        -- Function type, A -&gt; B
  deriving (Show, Eq)

-- Term definitions
data Term
  = Var String           -- Variable, e.g., &quot;x&quot;
  | App Term Term        -- Application, M N
  | Lam String Type Term -- Lambda abstraction, \x:A.M
  | Box Term             -- Boxing for !A
  deriving (Show, Eq)
</code></pre>
<p>These definitions capture the essence of EAL. For types, <code>TVar String</code> represents type variables. Bang Type introduces the <code>!A</code> modality, marking a type as reusable, which is crucial for EAL&#39;s promotion rule. <code>Type :-&gt; Type</code> defines function types (e.g., <code>A -&gt; B</code>), mirroring the arrow type in lambda calculus. For terms, <code>Var String</code> represents variables (e.g., &quot;x&quot;) associated with types in the context. <code>App Term</code> Term corresponds to applying one term to another (e.g., <code>M N</code>). <code>Lam String Type Term</code> represents lambda abstraction (e.g., <code>λx:A.M</code>), binding a variable to its type for function definitions. Finally, <code>Box Term</code> wraps a term to assign it the type <code>!A</code>, enabling controlled reuse through the bang modality.</p>
<p>Now, we need to define the context and how do we interact with it.
We need to track down variable usages. Note that this could be done only via typing, i.e we could enforce the affine property in the type of the context instead of naively implementing it in the functions. The way is done here, if a context is already broken on creation, an error will not pop. But since this is a toy implementation, im ok with that.</p>
<pre><code class="language-haskell">type Ann = (String, Type)  -- Annotated variable, e.g., (&quot;x&quot;, TVar &quot;a&quot;)
type Ctx = [Ann]           -- Context as a list of annotations
type UsedVars = [String]   -- List of variables used so far

-- Extend context with a new variable
extend :: Ctx -&gt; Ann -&gt; Either String Ctx
extend ctx ann@(var, typ) =
  case lookup var ctx of
    Just _  -&gt; Left (&quot;Variable &quot; ++ var ++ &quot; used more than once.&quot;)
    Nothing -&gt; Right (ann : ctx)

-- Filter out used variables, keeping banged ones
filterUsed :: Ctx -&gt; [String] -&gt; Ctx
filterUsed ctx used = filter (\(s, t) -&gt; s `notElem` used || case t of Bang _ -&gt; True; _ -&gt; False) ctx

-- Check if all variables are banged
allBanged :: Ctx -&gt; Bool
allBanged ctx = all (\(_, t) -&gt; case t of Bang _ -&gt; True; _ -&gt; False) ctx
</code></pre>
<p>Here, <code>Ann</code> and <code>Ctx</code> define the structure of the typing context, pairing variables with their types. <code>UsedVars</code> tracks consumed variables, ensuring non-banged variables are not reused. The extend function adds a new variable to the context but fails if the variable is already present, reflecting EAL&#39;s no-contraction rule. <code>filterUsed</code> updates the context after a variable is used: non-banged variables are removed once consumed, while banged variables (!A) remain available, aligning with the dereliction and contraction rules. <code>allBanged</code> checks if every variable in the context has a banged type, a prerequisite for the promotion rule used in the Box construct. These mechanisms ensure the context accurately reflects variable availability, respecting affine constraints and the exceptions granted by the bang modality.</p>
<p>Now let&#39;s do some type checking!</p>
<p>The core of the implementation lies in the typeCheck function, which enforces EAL&#39;s typing rules across four patterns: variables, application, lambda abstraction, and boxing:</p>
<pre><code class="language-haskell">typeCheck :: Ctx -&gt; Term -&gt; Either String (Type, UsedVars)
-- Variable case
typeCheck ctx (Var x) =
  case lookup x ctx of
    Just (Bang t) -&gt; Right (t, [])       -- Banged variable, reusable
    Just t        -&gt; Right (t, [x])      -- Non-banged, used once
    Nothing       -&gt; Left $ &quot;Variable &quot; ++ x ++ &quot; not found in context&quot;

-- Application case
typeCheck ctx (App m n) = do
  (typM, varsM) &lt;- typeCheck ctx m
  case typM of
    a :-&gt; b -&gt; do
      let newCtx = filterUsed ctx varsM
      (typN, varsN) &lt;- typeCheck newCtx n
      if typN == a
        then Right (b, varsM ++ varsN)
        else Left (&quot;Type Mismatch. Expected: &quot; ++ show typN ++ &quot; to be of type &quot; ++ show a)
    _ -&gt; Left &quot;Application requires a function type&quot;

-- Lambda case
typeCheck ctx (Lam bound typ bod) = do
  newCtx &lt;- extend ctx (bound, typ)
  (typBod, varsBod) &lt;- typeCheck newCtx bod
  let lamTyp = typ :-&gt; typBod
  let freeVars = filter (/= bound) varsBod
  Right (lamTyp, freeVars)

-- Box case
typeCheck ctx (Box t) = do
  if allBanged ctx
    then do
      (typT, varsT) &lt;- typeCheck ctx t
      Right (Bang typT, varsT)
    else Left &quot;Promotion requires a context of only banged types&quot;
</code></pre>
<p>Each case corresponds to a specific typing rule in EAL, which we&#39;ll now examine using standard type theory notation.</p>
<p>Variable (Var x)</p>
<pre><code> x : A ∈ Γ 
------------ (if A is not banged)
 Γ ⊢ x : A


 x : !A ∈ Γ
------------ (dereliction for banged variables)
 Γ ⊢ x : A
</code></pre>
<p>For a variable x, the type checker looks it up in the context. If x has a banged type (!A), it can be used as A without being consumed, thanks to the dereliction rule, so it&#39;s not added to the list of used variables. If x has a non-banged type (A), it&#39;s used once and marked as consumed. This enforces EAL&#39;s no-contraction rule while allowing banged variables to persist.</p>
<p>Application (App m n)</p>
<pre><code> Γ ⊢ M : A → B   Δ ⊢ N : A
--------------------------
  Γ,Δ ⊢ M N : B
</code></pre>
<p>To type M N, the type checker first types M in the current context to obtain its type, which must be a function A -&gt; B. It then filters the context to remove any non-banged variables used in M, ensuring they aren&#39;t reused illicitly. Next, it types N in this updated context to check if its type matches A. If so, the application is typed as B, and the used variables from both M and N are combined.</p>
<p>Lambda (Lam bound typ bod)</p>
<pre><code>   Γ, x : A ⊢ M : B
-----------------------
  Γ ⊢ λx : A.M : A → B
</code></pre>
<p>Typing Rule:</p>
<p>For a lambda abstraction \x:A.M, the type checker extends the context with x : A, ensuring x is fresh per the no-contraction rule. It then types the body M in this extended context to determine its type B. The overall type of the lambda is A -&gt; B, and any variables used in the body (except x) are tracked for future checks.</p>
<p>Box (Box t) - Promotion</p>
<pre><code>  Γ ⊢ M : A where Γ = x1 : !A1, ..., xn : !An
-----------------------------------------------
                  Γ ⊢ !M : !A
</code></pre>
<p>The Box construct implements the promotion rule, allowing a term M to be &quot;boxed&quot; into !A if it can be typed in a context where all variables are banged, checked using allBanged. If the condition holds, the type checker types M in the current context and wraps its type in Bang, enabling reuse. If the context contains non-banged variables, the promotion fails, enforcing EAL&#39;s strict conditions for reuse.</p>
<p>EAL&#39;s power lies in guaranteeing that any term it types will normalize in elementary time, often achieved through reduction strategies like Lamping&#39;s algorithm, which optimizes the reduction process by minimizing redundant steps. The combination of strict variable usage and controlled reuse via the bang modality ensures that reduction complexity is bounded predictably. However, this comes at the cost of some expressiveness.</p>
<h2>References and Further Reading</h2>
<p><a href="https://doi.org/10.1007/11417170_6">Baillot, P., Terui, K. (2005). A Feasible Algorithm for Typing in Elementary Affine Logic. In: Urzyczyn, P. (eds) Typed Lambda Calculi and Applications. TLCA 2005. Lecture Notes in Computer Science, vol 3461. Springer, Berlin, Heidelberg.</a></p>
<p><a href="https://doi.org/10.1007/11417170_11">Coppola, P., Dal Lago, U., Della Rocca, S.R. (2005). Elementary Affine Logic and the Call-by-Value Lambda Calculus. In: Urzyczyn, P. (eds) Typed Lambda Calculi and Applications. TLCA 2005. Lecture Notes in Computer Science, vol 3461. Springer, Berlin, Heidelberg.</a></p>
<p><a href="https://www.academia.edu/73045075/Principal_Typing_for_Lambda_Calculus_in_Elementary_Affine_Logic">Coppola, Paolo. “Principal Typing for Lambda Calculus in Elementary Affine Logic.” Fundamenta Informaticae (2005): n. pag. Print.</a></p>
<p><a href="https://arxiv.org/abs/1805.07518">Affine logic for constructive mathematics</a></p>
</div></article></main><footer><div class="footer-content"><p><a href="https://github.com/Lorenzobattistela" target="_blank" rel="noopener noreferrer">GitHub</a></p></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"eal","contentHtml":"\u003cp\u003eElementary Affine Logic (EAL) is a type system designed to guarantee that programs terminate in elementary time—a complexity class bounded by finite towers of exponentials, such as \n\u003ccode\u003e2^(2^n)\u003c/code\u003e\n. This makes EAL a powerful framework for reasoning about computational efficiency in a rigorous way. For this article, we\u0026#39;ll focus on propositional EAL without quantification, keeping our exploration accessible while diving into its core concepts and implementation. It is important to note that the implementation is not focusing on performance and not performing type inference, only basic type checking.\u003c/p\u003e\n\u003cp\u003eEAL is built upon affine logic, a substructural logic that modifies traditional proof theory by rejecting the contraction rule, which prevents assumptions from being reused multiple times, while embracing weakening, allowing unused variables to remain in the context. This contrasts with linear logic, where variables must be used exactly once; affine logic relaxes this to \u0026quot;at most once,\u0026quot; providing flexibility to ignore resources if they are not needed. In the context of programming, particularly within lambda calculus, this translates to a system where function arguments are used at most once, with some potentially left unused. EAL extends this foundation to target terms that align with the computational power of elementary bounded Turing machines. It also connects to Lamping\u0026#39;s optimal reduction algorithm, which minimizes the number of beta-reduction steps, ensuring efficient normalization of terms.\u003c/p\u003e\n\u003ch3\u003eCore Characteristics of EAL\u003c/h3\u003e\n\u003cp\u003eEAL is specifically crafted to type terms that can be reduced in elementary time, leveraging affine logic\u0026#39;s resource-sensitive nature. Variables cannot be reused unless explicitly marked with the bang modality (!A), which allows controlled reuse, while unused assumptions are permitted, aligning with the weakening rule. The bang modality (!A) is central to EAL, selectively relaxing the \u0026quot;at most once\u0026quot; rule to balance efficiency and flexibility. However, this imposes restrictions, preventing constructs like extensive variable sharing or polymorphism from being typed within the system—a necessary trade-off for EAL\u0026#39;s performance guarantees.\u003c/p\u003e\n\u003ch3\u003eImplementing EAL\u003c/h3\u003e\n\u003cp\u003eNow let\u0026#39;s gets get to work and write a simple implementation of EAL in Haskell.\nThis implementation focuses on the concept and the simple typing rules, not in\nperformance neither the type inference (that is more complex).\u003c/p\u003e\n\u003cp\u003eThe first step is to define the types and terms that constitute the EAL system:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-haskell\"\u003e-- Type definitions\ndata Type\n  = TVar String          -- Type variable, e.g., \u0026quot;a\u0026quot;\n  | Bang Type            -- !A, for reusable terms\n  | Type :-\u0026gt; Type        -- Function type, A -\u0026gt; B\n  deriving (Show, Eq)\n\n-- Term definitions\ndata Term\n  = Var String           -- Variable, e.g., \u0026quot;x\u0026quot;\n  | App Term Term        -- Application, M N\n  | Lam String Type Term -- Lambda abstraction, \\x:A.M\n  | Box Term             -- Boxing for !A\n  deriving (Show, Eq)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese definitions capture the essence of EAL. For types, \u003ccode\u003eTVar String\u003c/code\u003e represents type variables. Bang Type introduces the \u003ccode\u003e!A\u003c/code\u003e modality, marking a type as reusable, which is crucial for EAL\u0026#39;s promotion rule. \u003ccode\u003eType :-\u0026gt; Type\u003c/code\u003e defines function types (e.g., \u003ccode\u003eA -\u0026gt; B\u003c/code\u003e), mirroring the arrow type in lambda calculus. For terms, \u003ccode\u003eVar String\u003c/code\u003e represents variables (e.g., \u0026quot;x\u0026quot;) associated with types in the context. \u003ccode\u003eApp Term\u003c/code\u003e Term corresponds to applying one term to another (e.g., \u003ccode\u003eM N\u003c/code\u003e). \u003ccode\u003eLam String Type Term\u003c/code\u003e represents lambda abstraction (e.g., \u003ccode\u003eλx:A.M\u003c/code\u003e), binding a variable to its type for function definitions. Finally, \u003ccode\u003eBox Term\u003c/code\u003e wraps a term to assign it the type \u003ccode\u003e!A\u003c/code\u003e, enabling controlled reuse through the bang modality.\u003c/p\u003e\n\u003cp\u003eNow, we need to define the context and how do we interact with it.\nWe need to track down variable usages. Note that this could be done only via typing, i.e we could enforce the affine property in the type of the context instead of naively implementing it in the functions. The way is done here, if a context is already broken on creation, an error will not pop. But since this is a toy implementation, im ok with that.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-haskell\"\u003etype Ann = (String, Type)  -- Annotated variable, e.g., (\u0026quot;x\u0026quot;, TVar \u0026quot;a\u0026quot;)\ntype Ctx = [Ann]           -- Context as a list of annotations\ntype UsedVars = [String]   -- List of variables used so far\n\n-- Extend context with a new variable\nextend :: Ctx -\u0026gt; Ann -\u0026gt; Either String Ctx\nextend ctx ann@(var, typ) =\n  case lookup var ctx of\n    Just _  -\u0026gt; Left (\u0026quot;Variable \u0026quot; ++ var ++ \u0026quot; used more than once.\u0026quot;)\n    Nothing -\u0026gt; Right (ann : ctx)\n\n-- Filter out used variables, keeping banged ones\nfilterUsed :: Ctx -\u0026gt; [String] -\u0026gt; Ctx\nfilterUsed ctx used = filter (\\(s, t) -\u0026gt; s `notElem` used || case t of Bang _ -\u0026gt; True; _ -\u0026gt; False) ctx\n\n-- Check if all variables are banged\nallBanged :: Ctx -\u0026gt; Bool\nallBanged ctx = all (\\(_, t) -\u0026gt; case t of Bang _ -\u0026gt; True; _ -\u0026gt; False) ctx\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, \u003ccode\u003eAnn\u003c/code\u003e and \u003ccode\u003eCtx\u003c/code\u003e define the structure of the typing context, pairing variables with their types. \u003ccode\u003eUsedVars\u003c/code\u003e tracks consumed variables, ensuring non-banged variables are not reused. The extend function adds a new variable to the context but fails if the variable is already present, reflecting EAL\u0026#39;s no-contraction rule. \u003ccode\u003efilterUsed\u003c/code\u003e updates the context after a variable is used: non-banged variables are removed once consumed, while banged variables (!A) remain available, aligning with the dereliction and contraction rules. \u003ccode\u003eallBanged\u003c/code\u003e checks if every variable in the context has a banged type, a prerequisite for the promotion rule used in the Box construct. These mechanisms ensure the context accurately reflects variable availability, respecting affine constraints and the exceptions granted by the bang modality.\u003c/p\u003e\n\u003cp\u003eNow let\u0026#39;s do some type checking!\u003c/p\u003e\n\u003cp\u003eThe core of the implementation lies in the typeCheck function, which enforces EAL\u0026#39;s typing rules across four patterns: variables, application, lambda abstraction, and boxing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-haskell\"\u003etypeCheck :: Ctx -\u0026gt; Term -\u0026gt; Either String (Type, UsedVars)\n-- Variable case\ntypeCheck ctx (Var x) =\n  case lookup x ctx of\n    Just (Bang t) -\u0026gt; Right (t, [])       -- Banged variable, reusable\n    Just t        -\u0026gt; Right (t, [x])      -- Non-banged, used once\n    Nothing       -\u0026gt; Left $ \u0026quot;Variable \u0026quot; ++ x ++ \u0026quot; not found in context\u0026quot;\n\n-- Application case\ntypeCheck ctx (App m n) = do\n  (typM, varsM) \u0026lt;- typeCheck ctx m\n  case typM of\n    a :-\u0026gt; b -\u0026gt; do\n      let newCtx = filterUsed ctx varsM\n      (typN, varsN) \u0026lt;- typeCheck newCtx n\n      if typN == a\n        then Right (b, varsM ++ varsN)\n        else Left (\u0026quot;Type Mismatch. Expected: \u0026quot; ++ show typN ++ \u0026quot; to be of type \u0026quot; ++ show a)\n    _ -\u0026gt; Left \u0026quot;Application requires a function type\u0026quot;\n\n-- Lambda case\ntypeCheck ctx (Lam bound typ bod) = do\n  newCtx \u0026lt;- extend ctx (bound, typ)\n  (typBod, varsBod) \u0026lt;- typeCheck newCtx bod\n  let lamTyp = typ :-\u0026gt; typBod\n  let freeVars = filter (/= bound) varsBod\n  Right (lamTyp, freeVars)\n\n-- Box case\ntypeCheck ctx (Box t) = do\n  if allBanged ctx\n    then do\n      (typT, varsT) \u0026lt;- typeCheck ctx t\n      Right (Bang typT, varsT)\n    else Left \u0026quot;Promotion requires a context of only banged types\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach case corresponds to a specific typing rule in EAL, which we\u0026#39;ll now examine using standard type theory notation.\u003c/p\u003e\n\u003cp\u003eVariable (Var x)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e x : A ∈ Γ \n------------ (if A is not banged)\n Γ ⊢ x : A\n\n\n x : !A ∈ Γ\n------------ (dereliction for banged variables)\n Γ ⊢ x : A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor a variable x, the type checker looks it up in the context. If x has a banged type (!A), it can be used as A without being consumed, thanks to the dereliction rule, so it\u0026#39;s not added to the list of used variables. If x has a non-banged type (A), it\u0026#39;s used once and marked as consumed. This enforces EAL\u0026#39;s no-contraction rule while allowing banged variables to persist.\u003c/p\u003e\n\u003cp\u003eApplication (App m n)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e Γ ⊢ M : A → B   Δ ⊢ N : A\n--------------------------\n  Γ,Δ ⊢ M N : B\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo type M N, the type checker first types M in the current context to obtain its type, which must be a function A -\u0026gt; B. It then filters the context to remove any non-banged variables used in M, ensuring they aren\u0026#39;t reused illicitly. Next, it types N in this updated context to check if its type matches A. If so, the application is typed as B, and the used variables from both M and N are combined.\u003c/p\u003e\n\u003cp\u003eLambda (Lam bound typ bod)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   Γ, x : A ⊢ M : B\n-----------------------\n  Γ ⊢ λx : A.M : A → B\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTyping Rule:\u003c/p\u003e\n\u003cp\u003eFor a lambda abstraction \\x:A.M, the type checker extends the context with x : A, ensuring x is fresh per the no-contraction rule. It then types the body M in this extended context to determine its type B. The overall type of the lambda is A -\u0026gt; B, and any variables used in the body (except x) are tracked for future checks.\u003c/p\u003e\n\u003cp\u003eBox (Box t) - Promotion\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e  Γ ⊢ M : A where Γ = x1 : !A1, ..., xn : !An\n-----------------------------------------------\n                  Γ ⊢ !M : !A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Box construct implements the promotion rule, allowing a term M to be \u0026quot;boxed\u0026quot; into !A if it can be typed in a context where all variables are banged, checked using allBanged. If the condition holds, the type checker types M in the current context and wraps its type in Bang, enabling reuse. If the context contains non-banged variables, the promotion fails, enforcing EAL\u0026#39;s strict conditions for reuse.\u003c/p\u003e\n\u003cp\u003eEAL\u0026#39;s power lies in guaranteeing that any term it types will normalize in elementary time, often achieved through reduction strategies like Lamping\u0026#39;s algorithm, which optimizes the reduction process by minimizing redundant steps. The combination of strict variable usage and controlled reuse via the bang modality ensures that reduction complexity is bounded predictably. However, this comes at the cost of some expressiveness.\u003c/p\u003e\n\u003ch2\u003eReferences and Further Reading\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://doi.org/10.1007/11417170_6\"\u003eBaillot, P., Terui, K. (2005). A Feasible Algorithm for Typing in Elementary Affine Logic. In: Urzyczyn, P. (eds) Typed Lambda Calculi and Applications. TLCA 2005. Lecture Notes in Computer Science, vol 3461. Springer, Berlin, Heidelberg.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://doi.org/10.1007/11417170_11\"\u003eCoppola, P., Dal Lago, U., Della Rocca, S.R. (2005). Elementary Affine Logic and the Call-by-Value Lambda Calculus. In: Urzyczyn, P. (eds) Typed Lambda Calculi and Applications. TLCA 2005. Lecture Notes in Computer Science, vol 3461. Springer, Berlin, Heidelberg.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.academia.edu/73045075/Principal_Typing_for_Lambda_Calculus_in_Elementary_Affine_Logic\"\u003eCoppola, Paolo. “Principal Typing for Lambda Calculus in Elementary Affine Logic.” Fundamenta Informaticae (2005): n. pag. Print.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/1805.07518\"\u003eAffine logic for constructive mathematics\u003c/a\u003e\u003c/p\u003e\n","title":"Elementary Affine Logic","description":"Understanding EAL and typechecking it","date":"2025-02-22"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"eal"},"buildId":"7XdtTWnKkLqV613zeyCgO","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>